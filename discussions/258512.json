[
  {
    "Id": "616313",
    "ThreadId": "258512",
    "Html": "\r\n<p>I have the following recursive method which takes the an XHTML document and marks nodes based on certain conditions and It is called like below for a number of HTML contents:-</p>\r\n<pre><code><span>&nbsp; &nbsp; </span><span>XmlDocument</span><span> document </span><span>=</span><span> </span><span>new</span><span> </span><span>XmlDocument</span><span>();</span><span><br>&nbsp; &nbsp; document</span><span>.</span><span>LoadXml</span><span>(</span><span>xmlAsString</span><span>);</span><span><br>&nbsp; &nbsp; </span><span>PrepNodesForDeletion</span><span>(</span><span>document</span><span>.</span><span>DocumentElement</span><span>,</span><span> document</span><span>.</span><span>DocumentElement</span><span>);</span><span><br></span></code></pre>\r\n<p>The method definition is below</p>\r\n<pre><code><span>/// &lt;summary&gt;</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>/// Recursive function to identify and mark all unnecessary nodes so that they can be removed from the document.</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>/// &lt;/summary&gt;</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>/// &lt;param name=&quot;nodeToCompareAgainst&quot;&gt;The node that we are recursively comparing all of its descendant nodes against&lt;/param&gt;</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>/// &lt;param name=&quot;nodeInQuestion&quot;&gt;The node whose children we are comparing against the &quot;nodeToCompareAgainst&quot; node&lt;/param&gt;</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>static</span><span> </span><span>void</span><span> </span><span>PrepNodesForDeletion</span><span>(</span><span>XmlNode</span><span> nodeToCompareAgainst</span><span>,</span><span> </span><span>XmlNode</span><span> nodeInQuestion</span><span>)</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>if</span><span> </span><span>(</span><span>infinityIndex</span><span>&#43;&#43;</span><span> </span><span>&gt;</span><span> </span><span>100000</span><span>)</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>throw</span><span>;</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>}</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>foreach</span><span> </span><span>(</span><span>XmlNode</span><span> childNode </span><span>in</span><span> nodeInQuestion</span><span>.</span><span>ChildNodes</span><span>)</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// make sure we compare all of the childNodes descendants to the nodeToCompareAgainst</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>PrepNodesForDeletion</span><span>(</span><span>nodeToCompareAgainst</span><span>,</span><span> childNode</span><span>);</span><span><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>if</span><span> </span><span>(</span><span>AreNamesSame</span><span>(</span><span>nodeToCompareAgainst</span><span>,</span><span> childNode</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>AllAttributesPresent</span><span>(</span><span>nodeToCompareAgainst</span><span>,</span><span> childNode</span><span>))</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// the function AnyAttributesWithDifferingValues assumes that all attributes are present between the two nodes</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>if</span><span> </span><span>(</span><span>AnyAttributesWithDifferingValues</span><span>(</span><span>nodeToCompareAgainst</span><span>,</span><span> childNode</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>InnerTextIsSame</span><span>(</span><span>nodeToCompareAgainst</span><span>,</span><span> childNode</span><span>))</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>MarkNodeForDeletion</span><span>(</span><span>nodeToCompareAgainst</span><span>);</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>}</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>else</span><span> </span><span>if</span><span> </span><span>(!</span><span>AnyAttributesWithDifferingValues</span><span>(</span><span>nodeToCompareAgainst</span><span>,</span><span> childNode</span><span>))</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>MarkNodeForDeletion</span><span>(</span><span>childNode</span><span>);</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>}</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>}</span><span><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// make sure we compare all of the childNodes descendants to the childNode</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>PrepNodesForDeletion</span><span>(</span><span>childNode</span><span>,</span><span> childNode</span><span>);</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>}</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>}</span><span><br></span></code></pre>\r\n<p>And then the following method which would delete the marked node:-</p>\r\n<pre><code><span>&nbsp;</span><span>static</span><span> </span><span>void</span><span> </span><span>RemoveMarkedNodes</span><span>(</span><span>XmlDocument</span><span> document</span><span>)</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// in order for us to make sure we remove everything we meant to remove, we need to do this in a while loop</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// for instance, if the original xml is = &lt;a&gt;&lt;a&gt;&lt;b&gt;&lt;a/&gt;&lt;/b&gt;&lt;/a&gt;&lt;a/&gt;&lt;/a&gt;</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// this should result in the xml being passed into this function as:</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// &lt;a&gt;&lt;b&gt;&lt;a DeleteNode=&quot;TRUE&quot; /&gt;&lt;/b&gt;&lt;a DeleteNode=&quot;TRUE&quot;&gt;&lt;b&gt;&lt;a DeleteNode=&quot;TRUE&quot; /&gt;&lt;/b&gt;&lt;/a&gt;&lt;a DeleteNode=&quot;TRUE&quot; /&gt;&lt;/a&gt;</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// then this function (without the while) will not delete the last &lt;a/&gt;, even though it is marked for deletion</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// if we incorporate a while loop, then we can insure all nodes marked for deletion are removed</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>// TODO: understand the reason for this -- see http://groups.google.com/group/microsoft.public.dotnet.xml/browse_thread/thread/25df058a4efb5698/7dd0a8b71739216c?lnk=st&amp;q=xmlnode&#43;removechild&#43;recursive&amp;rnum=2&amp;hl=en#7dd0a8b71739216c</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>XmlNodeList</span><span> nodesToDelete </span><span>=</span><span> document</span><span>.</span><span>SelectNodes</span><span>(</span><span class=\"str\">&quot;//*[@DeleteNode='TRUE']&quot;</span><span>);</span><span><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>while</span><span> </span><span>(</span><span>nodesToDelete</span><span>.</span><span>Count</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>foreach</span><span> </span><span>(</span><span>XmlNode</span><span> nodeToDelete </span><span>in</span><span> nodesToDelete</span><span>)</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>{</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeToDelete</span><span>.</span><span>ParentNode</span><span>.</span><span>RemoveChild</span><span>(</span><span>nodeToDelete</span><span>);</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>}</span><span><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodesToDelete </span><span>=</span><span> document</span><span>.</span><span>SelectNodes</span><span>(</span><span class=\"str\">&quot;//*[@DeleteNode='TRUE']&quot;</span><span>);</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span>}</span><span><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span>}</span><span><br></span></code></pre>\r\n<p>When I use the &quot;PrepNodesForDeletion&quot; method without the infinityIndex counter, I get OutOfMemoryException for few HTML contents. However, If I use infinityIndex counter, It may not be deleting nodes for some HTML contents.</p>\r\n<p>Could you suggest anyway to remove recursion. Also I am not familiar with the HtmlAgility pack. So, If this can be done using that, could somebody provide some code sample.</p>\r\n",
    "PostedDate": "2011-05-21T17:15:12.327-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "625885",
    "ThreadId": "258512",
    "Html": "<p>You can use <span class=\"selflink\">System.Collections.Generic<span>.</span>Stack<span>&lt;</span>T<span>&gt; to rewrite the method so it does not use recursion. You will still need to check for cycles in your xml tree. The easiest way to do this would be to check if current node exists in, before adding it to, stack.</span></span></p>",
    "PostedDate": "2011-06-10T04:20:16.767-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]