[
  {
    "Id": "4020",
    "ThreadId": "1241",
    "Html": "\r\nI'm trying to use HtmlAgilityPack to scan Word documents saved as HTML.  There are a couple things that Word is doing that are confounding HtmlAgilityPack and before I invest too much time into a solution, I thought I'd see if you knew of other folks who had solved it already.<br /><br />When you use Word to create a document and \"Save As\" HTML, Word puts blocks like this into the &lt;head&gt;:<br /><br />&lt;!--<a href=\"http://www.codeplex.com/htmlagilitypack/Wiki/View.aspx?title=if%20gte%20mso%209\">if gte mso 9</a>&gt;&lt;xml&gt;<br />&lt;o:DocumentProperties&gt;<br /> &lt;o:Author&gt;Steve Benz&lt;/o:Author&gt;<br /> ...<br />&lt;/o:DocumentProperties&gt;<br />&lt;o:CustomDocumentProperties&gt;<br /> &lt;o:TestText dt:dt=\"string\"&gt;Yowsa.&lt;/o:TestText&gt;<br /> &lt;o:TestBool dt:dt=\"boolean\"&gt;1&lt;/o:TestBool&gt;<br /> &lt;o:TestNum dt:dt=\"float\"&gt;56&lt;/o:TestNum&gt;<br />&lt;/o:CustomDocumentProperties&gt;<br />&lt;/xml&gt;&lt;!<a href=\"http://www.codeplex.com/htmlagilitypack/Wiki/View.aspx?title=endif\">endif</a>--&gt;<br /><br />I'd like to use the HtmlAgilityPack to get at some of that data, but I'm having a couple problems.  First, it's hidden from HtmlAgilityPack's scanner by the \"&lt;!--...\" surrounding tags.  With those comments there, I'm unable to get at the &lt;xml&gt; tag or anything underneath it.<br /><br />What I considered doing to thwart that was to create a translation StreamReader, which would read my HTML file and strip out all those markers so that HtmlAgilityPack could actually see &lt;xml.../&gt;.  For test purposes, I manually removed the comments from my test file and tried again.<br /><br />At this point, I got an exception when I tried to do SelectNodes(\"//o:CustomDocumentProperties/*\").  That's because the XPath processor underlying the Agility Pack demands that the \"o\" namespace be resolvable.  I'm no expert on XPath etc., but still it seemed that the way to fix it was to alter HtmlNode's SelectNodes method so that it could take an IXmlNamespaceResolver argument to pass to XPathNodeIterator's Select method.  With that in place, it no longer throws the exception, but it also doesn't find the nodes either.<br /><br />I <b>could</b> use a preprocessor to clean those namespace qualifiers from the stream so that the agility pack could process it.  But surely there's a more elegant solution than that...<br /><br />Has anybody seen this problem before or otherwise know of a nice way to solve this?<br />",
    "PostedDate": "2006-09-05T13:57:18.643-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "4161",
    "ThreadId": "1241",
    "Html": "\r\nHi,<br /><br />hmmm. many questions!<br /><br />First of all, the Html Agility Pack parses comments (&lt;!-- --&gt; markup) and creates HtmlTextNode objects with it. So you can get all HtmlTextNodes, read comments, and use an XmlDocument on each (note the xml does not seem valid, you may have to add the namespace uri for the prefix o: manually)<br /><br />Concerning HTML namespaces and prefixes, the Html Agility Pack has very limited support for it. Basically, the : character is seen just like another character (not like in XML). Have you tried such a syntax:<br /><br />doc.DocumentNode.SelectNodes(\"//*<a href=\"http://www.codeplex.com/htmlagilitypack/Wiki/View.aspx?title=%27o%3aCustomDocumentProperties%27\">'o:CustomDocumentProperties'</a>\");<br /><br />It may work, but I prefer the first version (getting comment and loading an XmlDocument on it).<br />Simon.<br /><br />",
    "PostedDate": "2006-09-07T13:18:53.99-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "4482",
    "ThreadId": "1241",
    "Html": "\r\nI agree with your notion of parsing out the comments and feeding them to the native XML parser.  Afterall, the contents are <b>supposed</b> to be XML...  Whether they are or not is another matter, but yeah, that's the idea.<br /><br />I'm posting the solution that I came up with in case anybody else needs it and maybe others can improve on what I've got.<br /><br />My first problem was parsing out all the comments.  I really thought I could do:<br /><br />  HTMLDocument doc = ...;<br />  doc.DocumentNode.SelectNodes( \"//#comment\" );<br /><br />but I guess that just shows that my understanding of XPath is far from complete.  The only way I could figure to do it was to walk the tree myself.  I crafted this function to help me with that:<br /><br />  delegate void _ForeachComment( HtmlCommentNode comment );<br />  static void ForeachComment( HtmlNode rootNode, _ForeachComment doWhat )<br />  {<br />    if (rootNode.NodeType == HtmlNodeType.Comment)<br />      doWhat( (HtmlCommentNode)rootNode );<br />    foreach (HtmlNode n in rootNode.ChildNodes)<br />      ForeachComment( n, doWhat );<br />  }<br /><br />If this really is the only way to find comments and text nodes, then I'd recommend adding some walker API's to HtmlNode like the one shown above.  They facilitate some nice looking stuff:<br /><br />    ...<br />    ForeachComment( doc.DocumentNode, delegate( HtmlCommentNode n )<br />    {<br />      int xmlStart = n.Comment.IndexOf( \"&lt;xml&gt;\" );<br />      int xmlEnd = n.Comment.LastIndexOf( \"&lt;/xml&gt;\" );<br />      if (xmlStart &gt;= 0 &amp;&amp; xmlEnd &gt; xmlStart)<br />      {<br />        XmlDocument xmldoc = new XmlDocument();<br />        string rawXml = n.Comment.Substring( xmlStart, xmlEnd+6 - xmlStart );<br /><br />        xmldoc.LoadXml( DeNamespaceifyXML(rawXml) );<br />        XmlNodeList nl = xmldoc.SelectNodes( \"//CustomDocumentProperties/*\", nsMgr );<br />        if (nl != null)<br />        {<br />          foreach (XmlNode customDocNode in nl)<br />          {<br />            XmlAttribute dtAttr = customDocNode.Attributes<a href=\"http://www.codeplex.com/htmlagilitypack/Wiki/View.aspx?title=%22dt%22\">\"dt\"</a>;<br />            if (dtAttr != null)<br />            {<br />              string name = customDocNode.Name;<br />              string dt = dtAttr.Value;<br />              string text = customDocNode.InnerText;<br />              ...<br />            }<br />          }<br />        }<br />      }<br />    }<br />  );<br /><br />You're right that the XML scanner was not pleased with all the undeclared namespaces in the &lt;xml&gt; block.  I think the \"correct\" way to handle it would be to use the information from the &lt;html&gt; tag, which, for Word-saved HTML files looks like this:<br /><br />&lt;html xmlns:v=\"urn:schemas-microsoft-com:vml\"<br />xmlns:o=\"urn:schemas-microsoft-com:office:office\"<br />xmlns:w=\"urn:schemas-microsoft-com:office:word\"<br />xmlns:dt=\"uuid:C2F41010-65B3-11d1-A29F-00AA00C14882\"<br />xmlns=\"http://www.w3.org/TR/REC-html40\"&gt;<br /><br />You'd use that xmlns information to reconstruct the &lt;xml&gt; tag with appropriate namespace references.  But I skipped that in favor of a simpler solution.  I just wrote a regex to strip out the namespaces:<br /><br />    internal static string DeNamespaceifyXML( string xml )<br />    {<br />      Regex entities = new Regex( @\"(?&lt;before&gt;\\&lt;/?)\\w<u>\\:(?&lt;after&gt;\\w</u><a href=\"http://www.codeplex.com/htmlagilitypack/Wiki/View.aspx?title=%3e%20\">&gt; </a>)\" );<br />      string fixedEntities = entities.Replace( xml, delegate(Match m)<br />        {<br />          return m.Groups<a href=\"http://www.codeplex.com/htmlagilitypack/Wiki/View.aspx?title=%22before%22\">\"before\"</a>.Value + m.Groups<a href=\"http://www.codeplex.com/htmlagilitypack/Wiki/View.aspx?title=%22after%22\">\"after\"</a>.Value;<br />        }<br />      );<br /><br />      Regex attrs = new Regex( @\" \\w<u>\\:(\\w</u>)=\" );<br />      return attrs.Replace( fixedEntities, delegate( Match m )<br />        {<br />          return \" \" + m.Groups<a href=\"http://www.codeplex.com/htmlagilitypack/Wiki/View.aspx?title=1\">1</a>.Value + \"=\";<br />        }<br />      );<br />    }<br />",
    "PostedDate": "2006-09-12T11:13:23.76-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]